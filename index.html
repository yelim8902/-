<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>벌칙 룰렛 - 기본</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        /* 미니멀 컬러 팔레트 */
        --bg-color: #ffffff;
        --bg-subtle: #f7f8fa;
        --border-color: #e2e8f0;
        --text-primary: #1a202c;
        --text-secondary: #4a5568;
        --text-muted: #718096;

        /* 룰렛 원색 팔레트 */
        --roulette-red: #ff6b6b;
        --roulette-blue: #4d96ff;
        --roulette-yellow: #ffd93d;
        --roulette-green: #6bcb77;
        --roulette-purple: #9d4edd;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow-x: hidden;
      }

      /* 커스텀 스크롤바 스타일 */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }

      ::-webkit-scrollbar-track {
        background: var(--bg-subtle);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--text-muted);
      }

      /* Firefox 스크롤바 */
      * {
        scrollbar-width: thin;
        scrollbar-color: var(--border-color) var(--bg-subtle);
      }

      body {
        font-family: "Noto Sans KR", -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        width: 100%;
        height: 100%;
        min-height: 100vh;
        min-height: -webkit-fill-available; /* 모바일 주소창 대응 */
        margin: 0;
        padding: 0;
        background: var(--bg-color);
        display: flex;
        overflow-y: auto;
        overflow-x: hidden;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        position: relative;
      }

      .container {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 24px;
        padding: 30px 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3),
          0 0 0 1px rgba(255, 255, 255, 0.5);
        max-width: 600px;
        width: 100%;
        margin: 20px;
        position: relative;
        z-index: 1;
        animation: containerPop 0.6s ease-out;
      }

      /* 모바일 화면 최적화 */
      @media (max-width: 768px) {
        .container {
          margin: 10px;
          padding: 20px 15px;
          border-radius: 20px;
        }
      }

      @keyframes containerPop {
        from {
          opacity: 0;
          transform: scale(0.9) translateY(20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      h1 {
        text-align: center;
        margin-bottom: 10px;
        font-size: 2.5em;
        font-weight: 700;
        letter-spacing: -0.02em;
        transition: color 0.3s ease;
      }

      .subtitle {
        text-align: center;
        color: var(--text-secondary);
        margin-bottom: 30px;
        font-size: 0.9em;
        font-weight: 400;
      }

      .version-switch {
        text-align: center;
        margin-bottom: 20px;
      }

      .version-link {
        display: inline-block;
        color: var(--text-secondary);
        text-decoration: none;
        font-weight: 500;
        padding: 8px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-color);
        transition: all 0.2s;
        font-size: 0.85em;
        cursor: pointer;
        font-family: "Noto Sans KR", sans-serif;
      }

      .version-link:hover {
        background: var(--bg-subtle);
        border-color: var(--text-muted);
        color: var(--text-primary);
      }

      .roulette-container {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 30px 0;
      }

      #rouletteCanvas {
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        transition: box-shadow 0.3s ease;
        transform-origin: center center;
        max-width: 100%;
        height: auto;
      }

      /* 모바일 최적화 */
      @media (max-width: 768px) {
        #rouletteCanvas {
          width: 90vw;
          max-width: 400px;
        }

        .roulette-container {
          margin: 20px 0;
        }

        .pointer {
          top: -10px;
          border-left: 10px solid transparent;
          border-right: 10px solid transparent;
          border-top: 20px solid #2d3436;
        }

        h1 {
          font-size: 2em;
        }

        .container {
          margin: 10px;
          padding: 20px 15px;
        }
      }

      @media (max-width: 480px) {
        #rouletteCanvas {
          width: 85vw;
          max-width: 350px;
        }

        h1 {
          font-size: 1.8em;
        }
      }

      .pointer {
        position: absolute;
        top: -12px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 12px solid transparent;
        border-right: 12px solid transparent;
        border-top: 24px solid #2d3436;
        z-index: 10;
        filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
      }

      .controls {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 20px;
      }

      .power-gauge-container {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 10px;
      }

      .power-gauge-wrapper {
        position: relative;
        width: 100%;
        height: 24px;
        background: var(--bg-subtle);
        border-radius: 12px;
        border: 1px solid var(--border-color);
        overflow: hidden;
      }

      .power-gauge-fill {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 0%;
        background: linear-gradient(
          90deg,
          #ffd93d 0%,
          #ff6b6b 50%,
          #9d4edd 100%
        );
        border-radius: 11px;
        transition: width 0.1s linear;
      }

      .power-gauge-fill.max-power {
        background: linear-gradient(
          90deg,
          #ffd93d 0%,
          #ff6b6b 50%,
          #9d4edd 100%
        );
      }

      .power-gauge-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.7em;
        font-weight: 600;
        color: var(--text-muted);
        z-index: 2;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
      }

      .power-gauge-text.show {
        opacity: 1;
      }

      .power-gauge-text.max-power {
        color: var(--text-primary);
        font-size: 0.75em;
        font-weight: 700;
      }

      .spin-button {
        background: var(--text-primary);
        color: var(--bg-color);
        border: none;
        padding: 16px 40px;
        font-size: 1.1em;
        font-weight: 600;
        border-radius: 12px;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
        position: relative;
      }

      .spin-button:hover:not(:active):not(.holding):not(:disabled) {
        background: var(--text-secondary);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.12);
        transform: translateY(-2px);
      }

      .spin-button:active,
      .spin-button.holding {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      .spin-button:disabled {
        background: var(--border-color);
        color: var(--text-muted);
        cursor: not-allowed;
        transform: none;
      }

      .penalty-list {
        background: var(--bg-subtle);
        border-radius: 12px;
        padding: 20px;
        text-align: center;
        border: 1px solid var(--border-color);
        max-height: 300px;
        overflow-y: auto;
        overflow-x: hidden;
      }

      /* 벌칙 리스트 내부 스크롤바 스타일 */
      .penalty-list::-webkit-scrollbar {
        width: 6px;
      }

      .penalty-list::-webkit-scrollbar-track {
        background: transparent;
      }

      .penalty-list::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 3px;
      }

      .penalty-list::-webkit-scrollbar-thumb:hover {
        background: var(--text-muted);
      }

      .penalty-list h3 {
        color: var(--text-primary);
        margin-bottom: 15px;
        font-size: 1em;
        font-weight: 500;
      }

      .penalty-items {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
      }

      .penalty-badge {
        background: linear-gradient(
          135deg,
          var(--color-pink-light) 0%,
          var(--color-plum-light) 100%
        );
        color: #2d3748;
        padding: 10px 18px;
        border-radius: 20px;
        font-size: 0.9em;
        font-weight: 500;
        border: 2px solid var(--color-pink-medium);
        box-shadow: 0 2px 8px var(--color-pink-light);
        transition: all 0.3s ease;
      }

      .penalty-badge:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 4px 12px var(--color-pink-medium);
        border-color: var(--color-pink-dark);
      }

      .input-section {
        display: flex;
        gap: 8px;
        margin-bottom: 20px;
        align-items: center;
      }

      #penaltyInput {
        flex: 1;
        padding: 12px 16px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 0.95em;
        outline: none;
        transition: all 0.2s;
        font-family: "Noto Sans KR", sans-serif;
        background: var(--bg-color);
        color: var(--text-primary);
      }

      #penaltyInput:focus {
        border-color: var(--text-primary);
        box-shadow: 0 0 0 3px rgba(26, 32, 44, 0.1);
      }

      #penaltyInput::placeholder {
        color: var(--text-muted);
      }

      .add-button {
        background: var(--bg-subtle);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        padding: 12px 20px;
        font-size: 0.95em;
        font-weight: 500;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        flex-shrink: 0;
      }

      .add-button:hover {
        background: var(--text-primary);
        color: var(--bg-color);
        border-color: var(--text-primary);
      }

      .reset-button {
        background: transparent;
        color: var(--text-muted);
        border: 1px solid var(--border-color);
        padding: 10px;
        font-size: 1.2em;
        font-weight: 400;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        flex-shrink: 0;
      }

      .reset-button:hover {
        background: var(--bg-subtle);
        color: var(--text-primary);
        border-color: var(--text-muted);
        transform: rotate(180deg);
      }

      .penalty-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        margin: 4px 0;
        background: var(--bg-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }

      .penalty-item span {
        color: var(--text-primary);
        font-size: 0.95em;
      }

      .delete-button {
        background: transparent;
        color: var(--text-muted);
        border: 1px solid var(--border-color);
        padding: 6px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 500;
        transition: all 0.2s;
      }

      .delete-button:hover {
        background: var(--bg-subtle);
        color: var(--text-primary);
        border-color: var(--text-muted);
      }

      .empty-message {
        text-align: center;
        color: var(--text-muted);
        padding: 20px;
        font-style: italic;
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .modal-content {
        background: var(--bg-color);
        padding: 40px;
        border-radius: 16px;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border: 1px solid var(--border-color);
        max-width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        overflow-x: hidden;
      }

      /* 모달 내부 스크롤바 스타일 */
      .modal-content::-webkit-scrollbar {
        width: 6px;
      }

      .modal-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .modal-content::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 3px;
      }

      .modal-content::-webkit-scrollbar-thumb:hover {
        background: var(--text-muted);
      }

      .modal-content h2 {
        color: var(--text-primary);
        margin-bottom: 20px;
        font-size: 2.2em;
        font-weight: 700;
      }

      .modal-content p {
        font-size: 1.3em;
        color: var(--text-primary);
        margin-bottom: 30px;
        font-weight: 500;
      }

      .modal-close {
        background: var(--text-primary);
        color: var(--bg-color);
        border: none;
        padding: 12px 32px;
        font-size: 1em;
        font-weight: 600;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .modal-close:hover {
        background: var(--text-secondary);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 id="mainTitle">벌칙 룰렛</h1>

      <div class="version-switch">
        <button id="modeSwitch" class="version-link">
          → 커플 룰렛으로 이동
        </button>
      </div>

      <div class="roulette-container">
        <div class="pointer"></div>
        <canvas id="rouletteCanvas" width="600" height="600"></canvas>
      </div>

      <div class="controls">
        <div class="power-gauge-container">
          <div class="power-gauge-wrapper">
            <div class="power-gauge-fill" id="powerGaugeFill"></div>
            <div class="power-gauge-text" id="powerGaugeText">
              버튼을 누르고 있으세요
            </div>
          </div>
        </div>
        <button class="spin-button" id="spinButton">돌리기</button>

        <div class="input-section">
          <input
            type="text"
            id="penaltyInput"
            placeholder="벌칙을 입력하세요..."
          />
          <button class="add-button" id="addButton">추가</button>
          <button class="reset-button" id="resetButton" title="초기화">
            ↻
          </button>
        </div>

        <div class="penalty-list" id="penaltyList">
          <!-- 벌칙 항목들이 여기에 동적으로 추가됨 -->
        </div>
      </div>
    </div>

    <!-- 결과 모달 -->
    <div class="modal" id="resultModal">
      <div class="modal-content">
        <h2>결과</h2>
        <p id="resultText"></p>
        <button class="modal-close" id="closeModal">확인</button>
      </div>
    </div>

    <script>
      // Canvas와 컨텍스트 가져오기
      const canvas = document.getElementById("rouletteCanvas");
      const ctx = canvas.getContext("2d");
      const spinButton = document.getElementById("spinButton");
      const addButton = document.getElementById("addButton");
      const resetButton = document.getElementById("resetButton");
      const penaltyInput = document.getElementById("penaltyInput");
      const penaltyList = document.getElementById("penaltyList");
      const resultModal = document.getElementById("resultModal");
      const resultText = document.getElementById("resultText");
      const closeModal = document.getElementById("closeModal");
      const mainTitle = document.getElementById("mainTitle");
      const modeSwitch = document.getElementById("modeSwitch");

      // 모드 데이터 구조
      const modes = {
        basic: {
          title: "벌칙 룰렛",
          switchText: "→ 커플 룰렛으로 이동",
          themeColor: "#1a202c",
          penalties: [
            "누나/언니/형/오빠 호칭 쓰기",
            "옆 테이블 가서 인사하고 오기",
            '부모님께 "키워주셔서 감사" 전화',
            '지인에게 전화해 "사랑해" 듣기',
            "2차 계산하기 (지갑 오픈)",
            "다같이 릴스/틱톡 찍기",
            "흑역사 엽사 공개",
            "카톡 프사 1시간 동안 엽사",
            "전애인/짝사랑 SNS 좋아요 누르기",
            "갤러리 10번째 사진 무조건 공개",
            '가족톡방 "사랑해" 보내고 캡쳐',
            "오늘 하루종일 극존칭 쓰기",
            '편의점 가서 "저 기억 안 나세요?" 묻기',
            "무반주 댄스 30초 (제로투 등)",
          ],
          colors: [
            "#FF6B6B", // 레드
            "#4D96FF", // 블루
            "#FFD93D", // 옐로우
            "#6BCB77", // 그린
            "#9D4EDD", // 퍼플
          ],
        },
        couple_normal: {
          title: "커플 룰렛 (보통맛)",
          switchText: "→ 매운맛으로 이동",
          themeColor: "#ff69b4",
          penalties: [
            "눈 마주치고 키스 10초 (눈 감기 금지)",
            "귀에 바람 불고 '사랑해' 속삭이기",
            "다음 데이트 풀코스 쏘기 (지갑 오픈)",
            "상대방 이름으로 애교 섞인 3행시 (무표정하면 딱밤)",
            "서로 등 밀어주기 (목욕탕/스파 데이트)",
            "'주인님' 호칭 쓰며 마사지 5분",
            "상대방 아랫입술 젤리처럼 '앙' 깨물기",
            "이성을 잃게 만드는 섹시 댄스",
            "백허그 하고 1분간 귓속말",
            "자신 있는 신체 부위 자랑하기",
            "공주님 안기로 스쿼트 5회",
            "무릎 베고 누워서 아이컨택 1분",
            "호캉스 쏘기 (날짜는 승자가 지정)",
          ],
          colors: [
            "#FF69B4", // 핫핑크
            "#FFB6C1", // 라이트핑크
            "#FF91A4", // 로즈핑크
            "#FFC0CB", // 핑크
            "#FFB3BA", // 바블검핑크
          ],
        },
        couple_spicy: {
          title: "19금 커플 룰렛 (매운맛)",
          switchText: "→ 벌칙 룰렛으로 이동",
          themeColor: "#ff1493",
          penalties: [
            "딥키스 10초 하기",
            "원하는 부위에 키스",
            "귀 깨물고 야한 말 속삭이기",
            "전신 마사지 10분 (부위 지정)",
            "입에서 입으로 얼음 옮기기",
            "상의 탈의 (or 옷 하나 벗기)",
            "무릎 위에 앉아서 게임하기",
            "무반주 섹시 댄스 30초",
            "원하는 코스프레 해주기 (약속)",
            "목덜미/쇄골에 진한 키스",
            "소원 1개 들어주기 (거부 불가)",
            "서로 꽉 껴안고 1분 버티기",
            "오늘 밤 '주인님'으로 모시기",
            "꽝 (다음 기회에...)",
          ],
          colors: [
            "#FF1493", // 딥핑크
            "#FF69B4", // 핫핑크
            "#FF6B9D", // 로즈
            "#FF91A4", // 로즈핑크
            "#C71585", // 미디엄 바이올렛 레드
          ],
        },
      };

      // 현재 모드 상태
      let currentMode = "basic";

      // 벌칙 데이터 배열 (사용자가 수정 가능)
      let penalties = [...modes[currentMode].penalties];

      // 룰렛 회전 관련 변수
      let currentRotation = 0;
      let isSpinning = false;

      // 파워 게이지 관련 변수
      const powerGaugeFill = document.getElementById("powerGaugeFill");
      const powerGaugeText = document.getElementById("powerGaugeText");
      let powerLevel = 0; // 0 ~ 100
      let isCharging = false;
      let chargeStartTime = 0;
      let chargeInterval = null;
      const MAX_CHARGE_TIME = 2000; // 최대 충전 시간 (2초)

      // 현재 모드의 룰렛 색상 가져오기
      function getColors() {
        return modes[currentMode].colors;
      }

      // 모드 전환 함수
      function switchMode() {
        // 모드 순환: basic -> couple_normal -> couple_spicy -> basic
        if (currentMode === "basic") {
          currentMode = "couple_normal";
        } else if (currentMode === "couple_normal") {
          currentMode = "couple_spicy";
        } else {
          currentMode = "basic";
        }
        const mode = modes[currentMode];

        // 제목 업데이트
        mainTitle.textContent = mode.title;
        mainTitle.style.color = mode.themeColor;

        // 모드 전환 버튼 텍스트 업데이트
        modeSwitch.textContent = mode.switchText;

        // 벌칙 목록 초기화
        penalties = [...mode.penalties];

        // 룰렛 회전 초기화
        currentRotation = 0;
        canvas.style.transform = "rotate(0deg)";

        // 파워 게이지 초기화
        powerLevel = 0;
        updatePowerGauge(0);

        // UI 업데이트
        updatePenaltyList();
        drawRoulette();
      }

      // 초기화
      function init() {
        // 현재 모드에 맞게 초기화
        const mode = modes[currentMode];
        mainTitle.textContent = mode.title;
        mainTitle.style.color = mode.themeColor;
        modeSwitch.textContent = mode.switchText;

        // 벌칙 목록 초기화 (중요!)
        penalties = [...mode.penalties];

        // 룰렛 회전 초기화
        currentRotation = 0;
        canvas.style.transform = "rotate(0deg)";
        // 파워 게이지 초기화
        powerLevel = 0;
        updatePowerGauge(0);
        updatePenaltyList();
        drawRoulette();
      }

      // 벌칙 목록 UI 업데이트
      function updatePenaltyList() {
        penaltyList.innerHTML = "";

        if (penalties.length === 0) {
          penaltyList.innerHTML =
            '<div class="empty-message">벌칙을 추가해주세요!</div>';
          return;
        }

        penalties.forEach((penalty, index) => {
          const item = document.createElement("div");
          item.className = "penalty-item";
          item.innerHTML = `
                    <span>${penalty}</span>
                    <button class="delete-button" onclick="deletePenalty(${index})">삭제</button>
                `;
          penaltyList.appendChild(item);
        });
      }

      // 벌칙 삭제 함수
      function deletePenalty(index) {
        penalties.splice(index, 1);
        updatePenaltyList();
        drawRoulette();
      }

      // 벌칙 추가 함수
      function addPenalty() {
        const text = penaltyInput.value.trim();
        if (text === "") {
          alert("벌칙을 입력해주세요!");
          return;
        }
        if (penalties.includes(text)) {
          alert("이미 존재하는 벌칙입니다!");
          return;
        }
        penalties.push(text);
        penaltyInput.value = "";
        updatePenaltyList();
        drawRoulette();
      }

      // 벌칙 초기화 함수
      function resetPenalties() {
        if (confirm("벌칙 목록을 초기 상태로 되돌리시겠습니까?")) {
          penalties = [...modes[currentMode].penalties];
          updatePenaltyList();
          drawRoulette();
        }
      }

      // 텍스트를 여러 줄로 나누는 함수
      function wrapText(text, maxWidth) {
        const words = text.split("/");
        const lines = [];
        let currentLine = "";

        words.forEach((word, index) => {
          const testLine = currentLine + (currentLine ? "/" : "") + word;
          const metrics = ctx.measureText(testLine);
          const testWidth = metrics.width;

          if (testWidth > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }

          // 마지막 단어이거나 "/"가 없는 경우
          if (index === words.length - 1) {
            lines.push(currentLine);
          }
        });

        // 너무 길면 강제로 나누기
        if (lines.length === 0 || (lines.length === 1 && text.length > 15)) {
          const mid = Math.ceil(text.length / 2);
          let splitPoint = mid;
          // 공백이나 특수문자 근처에서 나누기
          for (let i = mid - 3; i <= mid + 3; i++) {
            if (text[i] === " " || text[i] === "/" || text[i] === "(") {
              splitPoint = i + 1;
              break;
            }
          }
          lines[0] = text.substring(0, splitPoint).trim();
          lines[1] = text.substring(splitPoint).trim();
        }

        return lines.length > 0 ? lines : [text];
      }

      // 룰렛 그리기 함수
      function drawRoulette() {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 280;

        if (penalties.length === 0) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#f0f0f0";
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#999";
          ctx.font = "20px 'Noto Sans KR', sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("벌칙을 추가해주세요", centerX, centerY);
          return;
        }

        const anglePerItem = (Math.PI * 2) / penalties.length;

        // 배경 원 그리기
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();

        // 각 섹션 그리기
        penalties.forEach((penalty, index) => {
          const startAngle = index * anglePerItem;
          const endAngle = (index + 1) * anglePerItem;

          // 섹션 색상
          const currentColors = getColors();
          ctx.fillStyle = currentColors[index % currentColors.length];
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, startAngle, endAngle);
          ctx.closePath();
          ctx.fill();

          // 섹션 테두리 (부드러운 흰색)
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 3;
          ctx.stroke();

          // 텍스트 그리기
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(startAngle + anglePerItem / 2);

          const textRadius = radius * 0.68;
          const maxTextWidth = radius * 0.55; // 최대 텍스트 너비

          // 폰트 설정 (굵게, 조금 더 크게)
          ctx.font = "bold 13px 'Noto Sans KR', sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          // 텍스트를 여러 줄로 나누기
          const lines = wrapText(penalty, maxTextWidth);
          const lineHeight = 16;
          const totalHeight = (lines.length - 1) * lineHeight;
          const startY = -totalHeight / 2;

          // 각 줄 그리기
          lines.forEach((line, lineIndex) => {
            const y = startY + lineIndex * lineHeight;

            // 텍스트 그림자 효과 (부드러운 그림자)
            ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
            ctx.shadowBlur = 6;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            // 텍스트 외곽선 (부드러운 검은색 테두리)
            ctx.strokeStyle = "rgba(0, 0, 0, 0.4)";
            ctx.lineWidth = 3;
            ctx.lineJoin = "round";
            ctx.miterLimit = 2;
            ctx.strokeText(line, textRadius, y);

            // 그림자 효과 초기화
            ctx.shadowColor = "transparent";
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // 텍스트 본문 (흰색)
            ctx.fillStyle = "#FFFFFF";
            ctx.fillText(line, textRadius, y);
          });

          ctx.restore();
        });

        // 중앙 원 그리기
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
        ctx.fill();
        // 중앙 원 테두리 (모드에 따라 색상 변경)
        ctx.strokeStyle =
          currentMode === "couple_normal" || currentMode === "couple_spicy"
            ? "#ffc0cb"
            : "#e2e8f0";
        ctx.lineWidth = 3;
        ctx.stroke();
      }

      // 파워 게이지 업데이트
      function updatePowerGauge(level) {
        powerLevel = Math.min(100, Math.max(0, level));
        powerGaugeFill.style.width = powerLevel + "%";

        if (powerLevel >= 100) {
          powerGaugeFill.classList.add("max-power");
          powerGaugeText.classList.add("max-power", "show");
          powerGaugeText.textContent = "MAX!";
        } else if (powerLevel > 0) {
          powerGaugeFill.classList.remove("max-power");
          powerGaugeText.classList.remove("max-power");
          powerGaugeText.classList.add("show");
          powerGaugeText.textContent = Math.round(powerLevel) + "%";
        } else {
          powerGaugeFill.classList.remove("max-power");
          powerGaugeText.classList.remove("max-power", "show");
          powerGaugeText.textContent = "";
        }
      }

      // 파워 충전 시작
      function startCharging() {
        if (isSpinning || isCharging) return;
        if (penalties.length === 0) {
          alert("벌칙을 먼저 추가해주세요!");
          return;
        }

        isCharging = true;
        chargeStartTime = Date.now();
        spinButton.classList.add("holding");
        powerLevel = 0;
        updatePowerGauge(0);

        chargeInterval = setInterval(() => {
          const elapsed = Date.now() - chargeStartTime;
          const newPower = Math.min(100, (elapsed / MAX_CHARGE_TIME) * 100);
          updatePowerGauge(newPower);
        }, 16); // 약 60fps
      }

      // 파워 충전 중지 및 룰렛 회전
      function stopCharging() {
        if (!isCharging) return;

        isCharging = false;
        spinButton.classList.remove("holding");
        clearInterval(chargeInterval);

        // 파워 그대로 사용 (최소 파워 보장 제거 - 살살 누르면 반 바퀴도 못 돌 수 있음)
        spinRoulette(powerLevel);

        // 게이지 리셋
        setTimeout(() => {
          updatePowerGauge(0);
        }, 100);
      }

      // 룰렛 회전 애니메이션 (CSS Transition 사용)
      function spinRoulette(power) {
        if (isSpinning) return;
        isSpinning = true;
        spinButton.disabled = true;

        // 파워에 따른 회전 설정 (최소 0.5바퀴 ~ 파워 비례 추가)
        const baseSpins = 0.5; // 최소 반 바퀴부터 시작 (힘 없으면 1바퀴도 못 돔)
        const extraSpins = (power / 100) * 8; // 풀파워일 때 추가 8바퀴
        const totalSpins = baseSpins + extraSpins;

        // 랜덤 각도 추가
        const randomAngle = Math.floor(Math.random() * 360);

        // 목표 회전 각도 (현재 각도에 누적)
        const rotateAmount = totalSpins * 360 + randomAngle;
        currentRotation += rotateAmount;

        // 회전 시간 설정 (1.5초 ~ 5초)
        const duration = 1.5 + (power / 100) * 3.5;

        // 이전 transition 제거 (부드러운 전환을 위해)
        canvas.style.transition = "none";
        // 강제 리플로우 (브라우저가 스타일 변경을 인식하도록)
        canvas.offsetHeight;

        // CSS 애니메이션 적용 (핵심: cubic-bezier로 부드러운 감속)
        canvas.style.transition = `transform ${duration}s cubic-bezier(0.25, 0.1, 0.25, 1)`;
        canvas.style.transform = `rotate(${currentRotation}deg)`;

        // 룰렛을 회전하는 동안 계속 그리기
        const drawInterval = setInterval(() => {
          drawRoulette();
        }, 16); // 약 60fps

        // 애니메이션 종료 시점 처리
        setTimeout(() => {
          clearInterval(drawInterval);
          isSpinning = false;
          spinButton.disabled = false;

          // 다음 회전을 위해 transition을 잠시 해제
          canvas.style.transition = "none";

          showResult();
        }, duration * 1000);
      }

      // 결과 계산 및 표시 (각도 보정)
      function showResult() {
        // 현재 룰렛의 각도를 0~360도로 정규화
        const actualRotation = currentRotation % 360;
        const normalizedAngle =
          actualRotation < 0 ? actualRotation + 360 : actualRotation;

        // 화살표(12시 방향=270도)가 가리키는 지점 역산
        // (270 - 현재각도 + 360) % 360
        let pointerAngle = (270 - normalizedAngle + 360) % 360;

        // 해당 각도에 위치한 아이템 인덱스 찾기
        const anglePerItem = 360 / penalties.length;
        const index = Math.floor(pointerAngle / anglePerItem);

        // 인덱스가 범위를 벗어나지 않도록 보정
        const resultIndex =
          index >= penalties.length ? penalties.length - 1 : index;

        // 결과 출력
        const result = penalties[resultIndex];
        resultText.textContent = result;
        resultModal.style.display = "flex";
      }

      // 모달 닫기
      closeModal.addEventListener("click", () => {
        resultModal.style.display = "none";
      });

      resultModal.addEventListener("click", (e) => {
        if (e.target === resultModal) {
          resultModal.style.display = "none";
        }
      });

      // 돌리기 버튼 클릭
      // 파워 컨트롤 이벤트 (마우스)
      spinButton.addEventListener("mousedown", (e) => {
        e.preventDefault();
        startCharging();
      });

      spinButton.addEventListener("mouseup", (e) => {
        e.preventDefault();
        stopCharging();
      });

      spinButton.addEventListener("mouseleave", (e) => {
        if (isCharging) {
          stopCharging();
        }
      });

      // 파워 컨트롤 이벤트 (터치 - 모바일)
      spinButton.addEventListener("touchstart", (e) => {
        e.preventDefault();
        startCharging();
      });

      spinButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        stopCharging();
      });

      spinButton.addEventListener("touchcancel", (e) => {
        if (isCharging) {
          stopCharging();
        }
      });

      // 모드 전환 버튼 이벤트
      modeSwitch.addEventListener("click", switchMode);

      // 벌칙 추가 버튼 이벤트
      addButton.addEventListener("click", addPenalty);
      resetButton.addEventListener("click", resetPenalties);

      // 엔터 키로 벌칙 추가
      penaltyInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          addPenalty();
        }
      });

      // 초기화 실행
      init();
    </script>
  </body>
</html>
